<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>chaser_2_spr</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>dynamic_parent_obj</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>isChild = false;
initialized = false;
to_destroy = false;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (to_destroy) {
    instance_destroy();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (!isChild &amp;&amp; !initialized) {
    // Maximum linear force.
    max_swim_strength = 20;
    // Maximum rotational force.
    max_steering_strength = 10;
    // Higher value means it will slow down less as it approaches the target. 
    eagerness = .2;
    // How much energy it begins life with.
    starting_energy = 10000;
    // How much color matters when going after food.
    color_pref = 800;
    
    // How much the critter is discouraged by there being a wall between it and the food.
    // Larger value means that it's less likely to go for food behind walls. 
    wall_discouragement = 50000;
    
    // How big the white of the eye will be as a ratio of the eye white radius to inradius.
    eye_white_scale = .5;
    // How big the pupil of the eye will be as a ratio of pupil radius the eye white radius.
    pupil_scale = .5;
    
    body_coord = random_triangle(32, 15);
    
    perturb = true;
    if (perturb) {
        max_swim_strength  += rand_norm(0, max_swim_strength/2);
        max_steering_strength  += rand_norm(0, max_steering_strength/2);
        eagerness  += rand_norm(0, eagerness/2);
        color_pref += rand_norm(0, color_pref/2);
        wall_discouragement += rand_norm(0, wall_discouragement/2);
        eye_white_scale += rand_norm(0, eye_white_scale/3);
        pupil_scale += rand_norm(0, pupil_scale/3);
    }
    
    // RGB components of its color.
    r = random(255);
    g = random(255);
    b = random(255);
    
    // generation
    gen = 0;
}

if (!initialized) {
    fix = create_polygon_fix(body_coord);
    
    physics_fixture_set_density(fix, .3)//.5);
    physics_fixture_set_restitution(fix, 1);
    physics_fixture_set_collision_group(fix, 0);
    physics_fixture_set_linear_damping(fix, 1.2);
    physics_fixture_set_angular_damping(fix, .5);
    physics_fixture_set_friction(fix, .01);
    
    bound_fix = physics_fixture_bind(fix, self);
    physics_fixture_delete(fix);
    
    area = triangle_area(body_coord);
    inradius = triangle_inradius(body_coord);
    
    tail_loc = tail_coord(body_coord);
    
    white_radius = eye_white_scale * inradius;
    pupil_radius = pupil_scale * white_radius;

    // Basal metabolic rate - rate at which energy will decrease when at rest.
    basal = 10;
    // How much energy is replenished by eating food.
    food_energy = 7000;
    // Amount of energy required before a birth will occur.
    birthing_threshold =  21000;
    // The highest amount of energy it can have stored.
    max_energy = 3 * starting_energy;
    
    energy = starting_energy;
    image_blend = make_colour_rgb(r, g, b);
    phy_rotation = random(360);
    initialized = true;
    
    // How large of a bite is taken. TODO: Proportional to the area.
    bite_scale = 1;
    
    tail_frame = 0;
    tail_frame_length = 20;
    tail_frame_progress = 0;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (initialized) { 
    //target_food = instance_nearest(x, y, food_obj);
    
    // Set desirability SO LOW that no one could ever want it.
    max_desirability = -9999999;
    
    t_coord = select_target();
    target_x = t_coord[0];
    target_y = t_coord[1];
    
    dir = point_direction(x, y, target_x, target_y);
    dist = point_distance(x, y, target_x, target_y);
    
    rel_dir = dir + phy_rotation;
    
    // If it is sufficiently far away, swim as fast as possible.
    // If it is close to the target, ease up so as not to overshoot.
    swim_strength = min(max_swim_strength, dist * eagerness);
    
    if(instance_number(food_obj) == 0) {
        swim_strength = 0;
    }
    
    // The faster you swim, the faster you fade.
    energy -= abs(swim_strength);
    // But you always lose at least your basal.
    energy -= basal;
    
    dx = cos(degtorad(rel_dir)) * swim_strength;
    dx = max(dx, 0);
    dy = sin(degtorad(rel_dir)) * max_steering_strength;
    
    physics_apply_local_force(tail_loc[0], tail_loc[1], dx, dy);
    
    tail_frame_progress += swim_strength;
    if (tail_frame_progress &gt; tail_frame_length) {
        tail_frame++;
        if (tail_frame &gt; sprite_get_number(tail_spr)) {
            tail_frame = 0;
        }
        tail_frame_progress = 0;
    }
    
    // As it starves, its alpha goes to zero.
    // Alpha is scaled on starting energy, anything above starting energy
    // has alpha of 1.
    image_alpha = min(1, energy/starting_energy);
    
    if (energy &gt; birthing_threshold) {
        child = instance_create(x, y, chaser_obj);
        child.isChild = true;
        child.max_swim_strength = max_swim_strength + rand_norm(0, max_swim_strength/3);
        child.max_steering_strength = max_steering_strength + rand_norm(0, max_steering_strength/3);
        child.eagerness  = eagerness + rand_norm(0, eagerness/3);
        child.color_pref = color_pref + rand_norm(0, color_pref/3);
        child.wall_discouragement = wall_discouragement + rand_norm(0, wall_discouragement/3);
        
        child.eye_white_scale = eye_white_scale + rand_norm(0, eye_white_scale/5);
        child.pupil_scale = pupil_scale + rand_norm(0, pupil_scale/5);
        
        child.body_coord = mutate_triangle(body_coord, 9, 15);
        
        color_variation = 10;
        child.r = r + max(min(rand_norm(0, color_variation), 255), 0);
        child.g = g + max(min(rand_norm(0, color_variation), 255), 0);
        child.b = b + max(min(rand_norm(0, color_variation), 255), 0);
        
        energy /= 2;
        child.starting_energy = energy;
        
        child.gen = gen + 1;
    }
    
    if (energy &lt; 0) {
        to_destroy = true;
    } 
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="food_obj">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//ugly hack plz resolve
if (initialized) {
    // Get more energy from similarly colored food.
    color_sim = color_similarity(self, other);
    color_dampening = .6;
    color_sim *= color_dampening;
    color_multiplier = 1 + color_sim;
    
    // TODO don't let it eat more food than exists!
    meal_size = food_energy * color_multiplier * bite_scale;
    
    energy = min(max_energy, energy + meal_size);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="chaser_obj">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//ugly hack plz resolve
if (initialized &amp;&amp; other.initialized &amp;&amp; global.cannibals) {
    // Get more energy from similarly colored food.
    
    if (other.area &lt; area/2) {
        energy += other.energy;
    }
    
    if (area &lt; other.area/2) {
        to_destroy = true;
    }
    
    /*color_sim = color_similarity(self, other);
    color_dampening = .6;
    color_sim *= color_dampening;
    color_multiplier = 1 + color_sim;
    
    // TODO don't let it eat more food than exists!
    meal_size = food_energy * color_multiplier * bite_scale;
    
    energy = min(max_energy, energy + meal_size);*/
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (initialized) {
    
     //Don't draw tail until you can find a nice place for it.
    tail_offset = abs(tail_loc[0]) + (sprite_get_width(tail_spr) * image_xscale)/2;
    rad = degtorad(phy_rotation);
    tail_x =  x + (-1 * cos(rad) * tail_offset);
    tail_y = y + (-1 * sin(rad) * tail_offset);
    draw_sprite_ext(tail_spr, tail_frame, tail_x, tail_y, image_xscale, image_yscale, -1 * phy_rotation, c_white, image_alpha);
    
    
    // Rotate body
    for (var i = 0; i &lt; 3; i++) {
        rotated_pt = rotate_point(body_coord[i, 0], body_coord[i, 1], phy_rotation);
        rotated_body[i, 0] = rotated_pt[0];
        rotated_body[i, 1] = rotated_pt[1];
    }
    
    draw_set_alpha(image_alpha);
    draw_set_colour(image_blend);

    // Draw body
    draw_triangle(x + rotated_body[0, 0], y + rotated_body[0, 1],
                x + rotated_body[1, 0], y + rotated_body[1, 1],
                x + rotated_body[2, 0], y + rotated_body[2, 1], false);
    
    draw_set_colour(c_black);
    
    // Draw outline
    draw_triangle(x + rotated_body[0, 0], y + rotated_body[0, 1],
                    x + rotated_body[1, 0], y + rotated_body[1, 1],
                    x + rotated_body[2, 0], y + rotated_body[2, 1], true);
                  
   
    // Draw eye.
    //white_radius = inradius;
    //pupil_radius = 2.5;
    pupil_offset[0] = white_radius - pupil_radius;
    pupil_offset[1] = 0;
    
    white_offset = triangle_incenter(rotated_body);
    
    pupil_dir = point_direction(x + white_offset[0], y + white_offset[1], target_x, target_y)
    
    pupil_offset = rotate_point(pupil_offset[0], pupil_offset[1], -pupil_dir);
    
    
    draw_set_color(c_white);
    draw_circle(x + white_offset[0], y + white_offset[1], white_radius, false);
    
    draw_set_colour(c_black);
    draw_circle(x + white_offset[0] + pupil_offset[0], y + white_offset[1] + pupil_offset[1], pupil_radius, false);
                 
    draw_set_alpha(1);
    
    draw_set_color(c_white);
    if (global.draw_desire) {
        draw_line(x, y, target_x, target_y);
    }
    if (global.draw_generation) {
        draw_text(x, y - 20, string(gen));
    }
   // draw_text(x, y - 20, string(wall_discouragement));
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>2</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>1</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>1.20000004768372</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.5</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.00999999977648258</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>

<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>chaser_2_spr</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>dynamic_parent_obj</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>isChild = false;
initialized = false;
to_destroy = false;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (to_destroy) {
    instance_destroy();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (!isChild &amp;&amp; !initialized) {
    // Maximum linear force.
    max_swim_strength = 20;
    // Maximum rotational force.
    max_steering_strength = 10;
    // Higher value means it will slow down less as it approaches the target. 
    eagerness = .2;
    // How much energy it begins life with.
    starting_energy = 10000;
    // How much color matters when going after food.
    color_pref = 800;
    
    // How much the critter is discouraged by there being a wall between it and the food.
    // Larger value means that it's less likely to go for food behind walls. 
    wall_discouragement = 50000;
    
    image_xscale = 1;
    image_yscale = 1;
    
    perturb = true;
    if (perturb) {
        max_swim_strength  += rand_norm(0, max_swim_strength/2);
        max_steering_strength  += rand_norm(0, max_steering_strength/2);
        eagerness  += rand_norm(0, eagerness/2);
        color_pref += rand_norm(0, color_pref/2);
        wall_discouragement += rand_norm(0, wall_discouragement/2);
        
        //image_xscale += rand_norm(0, .1);
        //image_yscale += rand_norm(0, .1);
        
        image_xscale += rand_norm(0, .2);
        image_yscale += rand_norm(0, .2);
        
        image_xscale = max(image_xscale, .1);
        image_yscale = max(image_yscale, .1);
    }
    
    // RGB components of its color.
    r = random(255);
    g = random(255);
    b = random(255);
    
    // generation
    gen = 0;
}

if (!initialized) {

    fix = create_triangle_fix(16 * image_yscale, 32 * image_xscale);
    // If we are experimenting with skewed fixtures.
    if (global.fixture_experiment) {
        // Delete the unused normal fixture.
        physics_fixture_delete(fix);
        create_skew_traingle_fix(32 * image_xscale);
    }
    
    physics_fixture_set_density(fix, .3)//.5);
    physics_fixture_set_restitution(fix, 1);
    physics_fixture_set_collision_group(fix, 0);
    physics_fixture_set_linear_damping(fix, 1.2);
    physics_fixture_set_angular_damping(fix, .5);
    physics_fixture_set_friction(fix, .01);
    
    bound_fix = physics_fixture_bind(fix, self);
    physics_fixture_delete(fix);
    
    // TODO figure out better way than hardcoding sprite version.
    width = image_xscale * sprite_get_width(chaser_spr);

    // Basal metabolic rate - rate at which energy will decrease when at rest.
    basal = 10;
    // How much energy is replenished by eating food.
    food_energy = 7000;
    // Amount of energy required before a birth will occur.
    birthing_threshold =  21000;
    // The highest amount of energy it can have stored.
    max_energy = 3 * starting_energy;
    
    energy = starting_energy;
    image_blend = make_colour_rgb(r, g, b);
    phy_rotation = random(360);
    initialized = true;
    
    // How large of a bite is taken. Proportional to the area.
    bite_scale = 1;//image_xscale * image_yscale;
    
    tail_frame = 0;
    tail_frame_length = 20;
    tail_frame_progress = 0;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (initialized) { 
    //target_food = instance_nearest(x, y, food_obj);
    
    // Set desirability SO LOW that no one could ever want it.
    max_desirability = -9999999;
    
    // TODO have better default
    target_x = 0;
    target_y = 0;
    
    for (i = 0; i &lt; instance_number(food_obj); i += 1) {
        food = instance_find(food_obj, i);
        dist = point_distance(x, y, food.x, food.y);
        color_des = color_pref * color_similarity(self, food);
        desirability = (-1 * dist) + color_des;
        
        if (collision_line(x, y, food.x, food.y, wall_obj, false, true)) {
            desirability -= wall_discouragement;
        }
        if (desirability &gt; max_desirability) {
            max_desirability = desirability;
            target_x = food.x;
            target_y = food.y;
        }
    }
    
    //target_x = target_food.x
    //target_y = target_food.y
    
    dir = point_direction(x, y, target_x, target_y);
    dist = point_distance(x, y, target_x, target_y);
    
    rel_dir = dir + phy_rotation;
    
    // If it is sufficiently far away, swim as fast as possible.
    // If it is close to the target, ease up so as not to overshoot.
    swim_strength = min(max_swim_strength, dist * eagerness);
    
    if(instance_number(food_obj) == 0) {
        swim_strength = 0;
    }
    
    // The faster you swim, the faster you fade.
    energy -= abs(swim_strength);
    // But you always lose at least your basal.
    energy -= basal;
    
    dx = cos(degtorad(rel_dir)) * swim_strength;
    dx = max(dx, 0);
    dy = sin(degtorad(rel_dir)) * max_steering_strength;
    
    physics_apply_local_force(-1 * width/2, 0, dx, dy);
    
    tail_frame_progress += swim_strength;
    if (tail_frame_progress &gt; tail_frame_length) {
        tail_frame++;
        if (tail_frame &gt; sprite_get_number(tail_spr)) {
            tail_frame = 0;
        }
        tail_frame_progress = 0;
    }
    
    // As it starves, its alpha goes to zero.
    // Alpha is scaled on starting energy, anything above starting energy
    // has alpha of 1.
    image_alpha = min(1, energy/starting_energy);
    
    if (energy &gt; birthing_threshold) {
        child = instance_create(x, y, chaser_obj);
        child.isChild = true;
        child.max_swim_strength = max_swim_strength + rand_norm(0, max_swim_strength/3);
        child.max_steering_strength = max_steering_strength + rand_norm(0, max_steering_strength/3);
        child.eagerness  = eagerness + rand_norm(0, eagerness/3);
        child.color_pref = color_pref + rand_norm(0, color_pref/3);
        child.wall_discouragement = wall_discouragement + rand_norm(0, wall_discouragement/3);
        
        child.image_xscale = max(image_xscale + rand_norm(0, .02), .1);
        child.image_yscale = max(image_yscale + rand_norm(0, .02), .1);
        
        color_variation = 10
        child.r = r + max(min(rand_norm(0, color_variation), 255), 0);
        child.g = g + max(min(rand_norm(0, color_variation), 255), 0);
        child.b = b + max(min(rand_norm(0, color_variation), 255), 0);
        
        energy /= 2;
        child.starting_energy = energy;
        
        child.gen = gen + 1;
    }
    
    if (energy &lt; 0) {
        to_destroy = true;
    } 
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="food_obj">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//ugly hack plz resolve
if (initialized) {
    // Get more energy from similarly colored food.
    color_sim = color_similarity(self, other);
    color_dampening = .6;
    color_sim *= color_dampening;
    color_multiplier = 1 + color_sim;
    
    // TODO don't let it eat more food than exists!
    meal_size = food_energy * color_multiplier * bite_scale;
    
    energy = min(max_energy, energy + meal_size);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>draw_self();
if (initialized) {
    tail_offset = (width/2) + (sprite_get_width(tail_spr) * image_xscale)/2;
    rad = degtorad(phy_rotation);
    tail_x =  x + (-1 * cos(rad) * tail_offset);
    tail_y = y + (-1 * sin(rad) * tail_offset);
    draw_sprite_ext(tail_spr, tail_frame, tail_x, tail_y, image_xscale, image_yscale, -1 * phy_rotation, c_white, image_alpha);
    
    //draw_text(x, y - 20, string(gen));
    
    
    draw_line(x, y, target_x, target_y);
   // draw_text(x, y - 20, string(wall_discouragement));
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>2</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>1</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>1.20000004768372</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.5</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.00999999977648258</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>

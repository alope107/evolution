<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>chaser_2_spr</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>dynamic_parent_obj</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>isChild = false;
initialized = false;
to_destroy = false;
chosen = false;
reselect = floor(random(10));
reselect_limit = 10;
target = -2;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (to_destroy) {
    instance_destroy();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (!isChild &amp;&amp; !initialized) {
    m = base_phenotype();
    /*m = ds_map_create();
    // Maximum linear force.
    m[? "max_swim_strength"] = 20;
    show_debug_message(string(m[? "max_swim_strength"]));
    // Maximum rotational force.
    max_steering_strength = 10;
    // Higher value means it will slow down less as it approaches the target. 
    eagerness = .2;
    // How much energy it begins life with.
    starting_energy = 10000;
    // How much color matters when going after food.
    color_pref = 800;
    
    // How much the critter is discouraged by there being a wall between it and the food.
    // Larger value means that it's less likely to go for food behind walls. 
    wall_discouragement = 50000;
    
    // How big the white of the eye will be as a ratio of the eye white radius to inradius.
    eye_white_scale = .5;
    // How big the pupil of the eye will be as a ratio of pupil radius the eye white radius.
    pupil_scale = .5;*/
    
    body_coord = random_triangle(32, 15);
    
    perturb = true;
    if (perturb) {
        m[? "max_swim_strength"]  += rand_norm(0, m[? "max_swim_strength"]/2);
        m[? "max_steering_strength"]  += rand_norm(0, m[? "max_steering_strength"]/2);
        m[? "eagerness"]  += rand_norm(0, m[? "eagerness"]/2);
        m[? "color_pref"] += rand_norm(0, m[? "color_pref"]/2);
        m[? "wall_discouragement"] += rand_norm(0, m[? "wall_discouragement"]/2);
        m[? "eye_white_scale"] += rand_norm(0, m[? "eye_white_scale"]/3);
        m[? "pupil_scale"] += rand_norm(0, m[? "pupil_scale"]/3);
    }
    
    // RGB components of its color.
    r = random(255);
    g = random(255);
    b = random(255);
    
    // generation
    gen = 0;
}

if (!initialized) {
    fix = create_polygon_fix(body_coord);
    
    physics_fixture_set_density(fix, .3)//.5);
    physics_fixture_set_restitution(fix, 1);
    physics_fixture_set_collision_group(fix, 0);
    physics_fixture_set_linear_damping(fix, 1.2);
    physics_fixture_set_angular_damping(fix, .5);
    physics_fixture_set_friction(fix, .01);
    
    bound_fix = physics_fixture_bind(fix, self);
    physics_fixture_delete(fix);
    
    area = triangle_area(body_coord);
    inradius = triangle_inradius(body_coord);
    side_lengths = triangle_side_lengths(body_coord);
    
    tail_loc = tail_coord(body_coord);
    
    white_radius = m[? "eye_white_scale"] * inradius;
    pupil_radius = m[? "pupil_scale"] * white_radius;

    // Basal metabolic rate - rate at which energy will decrease when at rest.
    basal = 10;
    // How much energy is replenished by eating food.
    food_energy = 7000;
    // Amount of energy required before a birth will occur.
    birthing_threshold =  21000;
    // The highest amount of energy it can have stored.
    max_energy = 4 /*3*/ * m[? "starting_energy"];
    
    energy = m[? "starting_energy"];
    image_blend = make_colour_rgb(r, g, b);
    phy_rotation = random(360);
    initialized = true;
    
    // How large of a bite is taken. TODO: Proportional to the area.
    bite_scale = area / 200; //1
    
    tail_frame = 0;
    tail_frame_length = 20;
    tail_frame_progress = 0;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (initialized) { 
    // Set desirability SO LOW that no one could ever want it.
    max_desirability = -9999999;
    
    reselect += 1;
    
    if (reselect &gt; reselect_limit) {
        target = select_target();
        reselect = 0;
    }
    
    if (target == -2 || (target != -1 &amp;&amp; !instance_exists(target))) {
        target = select_target();
    }
    
    if (target == -1) {
        target_x = 0;
        target_y = 0;
    }
    else {
        target_x = (target).x;
        target_y = (target).y;
    }
    
    dir = point_direction(x, y, target_x, target_y);
    dist = point_distance(x, y, target_x, target_y);
    
    rel_dir = dir + phy_rotation;
    // If it is sufficiently far away, swim as fast as possible.
    // If it is close to the target, ease up so as not to overshoot.
    swim_strength = min(m[? "max_swim_strength"], dist * m[? "eagerness"]);
    
    if(instance_number(food_obj) == 0) {
        swim_strength = 0;
    }
    
    dx = cos(degtorad(rel_dir)) * swim_strength;
    dx = max(dx, 0);
    dy = sin(degtorad(rel_dir)) * m[? "max_steering_strength"];
    
    // Manual control
    if (chosen &amp;&amp; global.controlling) {
        dx = 0;
        dy = 0;
        if (keyboard_check(vk_up)) {
            dx = m[? "max_swim_strength"];
        }
        if ( keyboard_check(vk_left) &amp;&amp; ! keyboard_check(vk_right)) {
            dy = m[? "max_steering_strength"];
        }
        if ( keyboard_check(vk_right) &amp;&amp; ! keyboard_check(vk_left)) {
            dy = -1 * m[? "max_steering_strength"];
        }
    }
    
    physics_apply_local_force(tail_loc[0], tail_loc[1], dx, dy);
    
    // The faster you swim, the faster you fade.
    energy -= abs(swim_strength);
    // But you always lose at least your basal.
    energy -= basal;
    
    tail_frame_progress += swim_strength;
    if (tail_frame_progress &gt; tail_frame_length) {
        tail_frame++;
        if (tail_frame &gt; sprite_get_number(tail_spr)) {
            tail_frame = 0;
        }
        tail_frame_progress = 0;
    }
    
    // As it starves, its alpha goes to zero.
    // Alpha is scaled on starting energy, anything above starting energy
    // has alpha of 1.
    image_alpha = min(1, energy/m[? "starting_energy"]);
    
    if (energy &gt; birthing_threshold) {
        child = instance_create(x, y, chaser_obj);
        child.isChild = true;
        child.m = base_phenotype();
        child.m[? "max_swim_strength"] = m[? "max_swim_strength"] + rand_norm(0, m[? "max_swim_strength"]/3);
        child.m[? "max_steering_strength"] = m[? "max_steering_strength"] + rand_norm(0, m[? "max_steering_strength"]/3);
        child.m[? "eagerness"]  = m[? "eagerness"] + rand_norm(0, m[? "eagerness"]/3);
        child.m[? "color_pref"] = m[? "color_pref"] + rand_norm(0, m[? "color_pref"]/3);
        child.m[? "wall_discouragement"] = m[? "wall_discouragement"] + rand_norm(0, m[? "wall_discouragement"]/3);
        
        child.m[? "eye_white_scale"] = m[? "eye_white_scale"] + rand_norm(0, m[? "eye_white_scale"]/10);
        child.m[? "pupil_scale"] = m[? "pupil_scale"] + rand_norm(0, m[? "pupil_scale"]/10);
        
        child.body_coord = mutate_triangle(body_coord, 9, 15);
        
        color_variation = 10;
        child.r = r + max(min(rand_norm(0, color_variation), 255), 0);
        child.g = g + max(min(rand_norm(0, color_variation), 255), 0);
        child.b = b + max(min(rand_norm(0, color_variation), 255), 0);
        
        energy /= 2;
        child.starting_energy = energy;
        
        child.gen = gen + 1;
    }
    
    if (energy &lt; 0) {
        to_destroy = true;
    } 
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="food_obj">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//ugly hack plz resolve
if (initialized) {
    // Get more energy from similarly colored food.
    color_sim = color_similarity(self, other);
    color_dampening = .6;
    color_sim *= color_dampening;
    color_multiplier = 1 + color_sim;
    
    // TODO don't let it eat more food than exists!
    meal_size = food_energy * color_multiplier * bite_scale;
    
    energy = min(max_energy, energy + meal_size);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="chaser_obj">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//ugly hack plz resolve
if (initialized &amp;&amp; other.initialized &amp;&amp; global.cannibals) {
    // Get more energy from similarly colored food.
    
    if (other.area &lt; area/2) {
        energy += other.energy;
    }
    
    if (area &lt; other.area/2) {
        to_destroy = true;
    }
    
    /*color_sim = color_similarity(self, other);
    color_dampening = .6;
    color_sim *= color_dampening;
    color_multiplier = 1 + color_sim;
    
    // TODO don't let it eat more food than exists!
    meal_size = food_energy * color_multiplier * bite_scale;
    
    energy = min(max_energy, energy + meal_size);*/
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (initialized) {
    area_ratio = 1000
    tail_scale = area/area_ratio
    tail_offset = abs(tail_loc[0]) + (sprite_get_width(tail_spr) * tail_scale)/2;
    rad = degtorad(phy_rotation);
    tail_x =  x + (-1 * cos(rad) * tail_offset);
    tail_y = y + (-1 * sin(rad) * tail_offset);
    draw_sprite_ext(tail_spr, tail_frame, tail_x, tail_y, tail_scale, tail_scale, -1 * phy_rotation, c_white, image_alpha);
    
    
    // Rotate body
    for (var i = 0; i &lt; 3; i++) {
        rotated_pt = rotate_point(body_coord[i, 0], body_coord[i, 1], phy_rotation);
        rotated_body[i, 0] = rotated_pt[0];
        rotated_body[i, 1] = rotated_pt[1];
    }
    
    draw_set_alpha(image_alpha);
    draw_set_colour(image_blend);

    // Draw body
    draw_triangle(x + rotated_body[0, 0], y + rotated_body[0, 1],
                x + rotated_body[1, 0], y + rotated_body[1, 1],
                x + rotated_body[2, 0], y + rotated_body[2, 1], false);
    
    draw_set_colour(c_black);
    
    // Draw outline
    draw_triangle(x + rotated_body[0, 0], y + rotated_body[0, 1],
                    x + rotated_body[1, 0], y + rotated_body[1, 1],
                    x + rotated_body[2, 0], y + rotated_body[2, 1], true);
                    
    if (chosen) {
        draw_set_colour(c_red);
        draw_line_width(x + rotated_body[0, 0], y + rotated_body[0, 1], 
                        x + rotated_body[1, 0], y + rotated_body[1, 1], 3);
        draw_line_width(x + rotated_body[0, 0], y + rotated_body[0, 1], 
                        x + rotated_body[2, 0], y + rotated_body[2, 1], 3);
        draw_line_width(x + rotated_body[2, 0], y + rotated_body[2, 1], 
                        x + rotated_body[1, 0], y + rotated_body[1, 1], 3);
    }
                  
   
    // Draw eye.
    pupil_offset[0] = white_radius - pupil_radius;
    pupil_offset[1] = 0;
    white_offset = triangle_incenter(rotated_body, side_lengths);
    pupil_dir = point_direction(x + white_offset[0], y + white_offset[1], target_x, target_y)
    pupil_offset = rotate_point(pupil_offset[0], pupil_offset[1], -pupil_dir);
    
    
    draw_set_color(c_white);
    draw_circle(x + white_offset[0], y + white_offset[1], white_radius, false);
    
    draw_set_colour(c_black);
    draw_circle(x + white_offset[0] + pupil_offset[0], y + white_offset[1] + pupil_offset[1], pupil_radius, false);
                 
    draw_set_alpha(1);
    
    draw_set_color(c_white);
    if (global.draw_desire) {
        draw_line(x, y, target_x, target_y);
    }
    if (global.draw_generation) {
        draw_text(x, y - 20, string(gen));
    }
    if (global.draw_area) {
        draw_text(x, y + 20, string(area));
    }
    
    /*if (chosen) {
        draw_set_color(c_red);
        draw_text(x, y + 20, "ME");
        draw_set_color(c_white);
    }*/
   // draw_text(x, y - 20, string(wall_discouragement));
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>2</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>1</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>1.20000004768372</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.5</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.00999999977648258</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
